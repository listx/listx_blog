---
title: "Bresenham's Circle Drawing Algorithm"
tags: programming, math
mathjax: on
---

#+STARTUP: indent showall
#+OPTIONS: ^:nil

#+begin_export html
<!-- This is from https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html. -->
<!-- The `type=module` is required if we want to use the "import" statement. -->
<script type="module">
  import init from '../rust-js/js/rust_js.js';

  async function run() {
    await init();

    // Here we can use the JS generated by Rust. For example, you might do:
    //
    //    const result = add_from_rust(1, 2);
    //    console.log(`1 + 2 = ${result}`);
    //    if (result !== 3)
    //      throw new Error("wasm addition doesn't work!");
    //
    // However, the entrypoint() function in the Rust library calls the
    // "draw_all_circles()" function which finds all Canvas elements with
    // specially-named ID fields, so there is no need to call the functions from
    // here at all.
  }

  run();
</script>
#+end_export

Once upon a time I was given the following problem for a technical programming interview:

#+begin_quote
Write a function ~draw_circle(r)~ that draws a circle with radius ~r~. Use the given method ~draw_pixel(x, y)~ which takes a 2-dimensional point ~(x, y)~ and colors it in on the computer screen.
#+end_quote

For the solution, you can either collect all pixels (tuples) of $x$ and $y$ coordinate pairs, or just call ~draw_pixel()~ on them during the "search" for those pixels that must be filled in.

This post goes over several solutions, ultimately arriving at Bresenham's algorithm.
The content of this post is merely a distillation of Section 3.3 from the book "Computer Graphics: Principles and Practice (1996)".[fn:: Foley, J. D., van Dam, A., Feiner, S. K., Hughes, J. F. (1996). Basic Raster Graphics Algorithms for Drawing 2D Primitives, Scan Converting Circles. /Computer Graphics: Principles and Practice/ (pp. 81--87). Addison-Wesley. ISBN: 0201848406]
The authors of the book state that their implementation results in code "essentially the same as that specified in patent 4,371,933 [a.k.a. Bresenham's algorithm]."[fn::
Bresenham, J.E., D.G. Grice, and S.C. Pi, "Bi-Directional Display of Circular Arcs,"  US Patent 4,371,933. February 1, 1983. /Note: unfortunately, trying to understand the original text of the patent is perhaps equally as difficult as inventing the algorithm on your own from scratch. Hence this blog post./ ]

I've gone all out and converted the "reference" implementations found in the book and translated them into Rust and Python.
The Python was written first, and I used a text-based drawing system to test the correctness.
However I became dissatisfied with the non-square "aspect ratio" of most monospaced fonts out there, which distorted the circles to look more like ellipses.
To fix this, I decided to port the Python code to Rust, and then target WASM so that I can use it to draw on the HTML5 ~<canvas>~ elements (and to eliminate the "aspect ratio" problem).
All of the drawings in this document are powered by the Rust code.

* Constraints

** Drawable canvas

Before we start, let's define the drawable surface (canvas) of pixels for this problem.
The pixels are arranged in a 2-dimensional grid.
The important thing here is the grid or coordinate system, with the pixel at the center of the grid having the traditional ~(0, 0)~ Cartesian coordinate.

Below is a sample grid to give you a sense of what this will look like.
There is a central ~(0, 0)~ origin pixel, and 15 pixels to the north, south, east, and west, and everything in-between.
Pixels that lie on interesting points of symmetry are highlighted in green.

#+begin_export html
<canvas id="blank__14__20"></canvas>
#+end_export

** Mathematical definitions

The exact definition of a circle (given infinite precision, as on the traditional Cartesian plane) centered at the origin is

\[
\begin{equation} \label{eq:circle}
x^2 + y^2 = r^2.
\end{equation}
\]

This resembles the Pythagorean Theorem

\[
a^2 + b^2 = c^2,
\]

for any right-angled triangle with sides $a$ and $b$ and hypotenuse $c$.
The resemblance is not a coincidence, because an infinite number of such triangles exists within the top right quadrant of the plane (that is, Quadrant I[fn:: There are 4 such [[https://en.wikipedia.org/wiki/Quadrant_(plane_geometry)][quadrants]]: I, II, III, and IV.], or the part of the plane such that $x \geq 0$ and $y \geq 0$); in Quadrant I, for all points $(x,y)$ that make up this portion (or arc) of the circle, their radii is the same as the hypotenuses of these triangles (whose sides are $x$ and $y$).
Later in this post, this will become relevant again when we discuss [[https://en.wikipedia.org/wiki/Pythagorean_triple][Pythagorean Triples]].

Anyway, solving for $y$ in Equation \(\ref{eq:circle}\) gives

\[
\begin{equation} \label{eq:circle-y}
y = \pm\sqrt{r^2 - x^2}
\end{equation}
\]

to get 2 functions for the top-half and bottom-half of the circle (that's what the $\pm$ symbol means).
Consider the function $y = x$.
This function has slope 1 and is a diagonal line where all values of $x = y$.
Now consider how this line intersects the quarter-arc of the circle in Quadrant I.
This intersection point evenly divides the arc into 2 halves, and is where

\[
x = y = \tfrac{r}{\sqrt{2}},
\]

or simply the point

\[
\begin{equation} \label{eq:arc-intersection}
(\tfrac{r}{\sqrt{2}}, \tfrac{r}{\sqrt{2}}).
\end{equation}
\]

This is because if $x = y$, then Equation \(\ref{eq:circle}\) becomes

\[
\begin{align}
x^2 + y^2 &= r^2
\\
x^2 + x^2 &= r^2
\\
2x^2 &= r^2
\\
\tfrac{2x^2}{2} &= \tfrac{r^2}{2}
\\
x^2 &= \tfrac{r^2}{2}
\\
\sqrt{x^2} &= \tfrac{\sqrt{r^2}}{\sqrt{2}}
\\
x &= \tfrac{r}{\sqrt{2}}.
\end{align}
\]

This is not that interesting for purposes of the algorithms in this post, but is something that is glossed over in the book.

** Symmetry

Because of symmetry, we can mirror the solution $(x,y)$ pairs we get in Quadrant I into the other quadrants.
This gives us 4-way symmetry because there are 4 quadrants.

- i 2021-03-15-bresenham-circle-drawing-algorithm/lib.py 164-169

Note, however, that there is actually 8-way symmetry at hand because (1) we can swap $x$ and $y$, and (2) because of the way we can distribute the negative sign:

| # | Coordinate | Quadrant |
|---+------------+----------|
| 1 | ~( x, y)~  | I        |
| 2 | ~( y, x)~  | I        |
| 3 | ~(-x, y)~  | II       |
| 4 | ~(-y, x)~  | II       |
| 6 | ~(-x,-y)~  | III      |
| 5 | ~(-y,-x)~  | III      |
| 7 | ~( x,-y)~  | IV       |
| 8 | ~( y,-x)~  | IV       |

- i 2021-03-15-bresenham-circle-drawing-algorithm/lib.py 172-181

Fun fact: the exact point at which $x$ and $y$ get "swapped" in Quadrant I is when $x = y = \tfrac{r}{\sqrt{2}}$ (Equation \(\ref{eq:arc-intersection}\)).

* Naive solutions

When in doubt, brute force is always a great answer, because at least it gets you started on something that works given enough time and/or memory.[fn:: In some sense, all great algorithms are mere optimizations of brute force approaches.]
Because we already have clear mathematical definitions, we can just translate them (albeit mechanically) to code.

- i 2021-03-15-bresenham-circle-drawing-algorithm/naive.py 7-17

~get_circle_points_naive_4()~ is the simplest translation, although there is a bug, which is obvious when we visualize it (in this case, for $r = 15$):

#+begin_export html
<canvas id="naive_4__15__20"></canvas>
#+end_export

The ~get_circle_points_naive_4()~ is based on Equation \(\ref{eq:circle-y}\).
We iterate $x$ from $0$ to $r$ [fn:: In code, we have to write ~range(r + 1)~ because the ~range()~ function does not include the last integer. Such "fence-post" or "off by one" logic is the bane of computer programmers.], and at each $x$ try to find the best value for $y$.
The problem is that we're only solving for 1 $y$ value for every $x$ value we increment by.
As we get near the left and right sides of the circle, we need to calculate more than just 1 $y$ value for every $x$.[fn::  Mathematically, this is because the slope of the arc in Equation \(\ref{eq:circle-y}\) approach positive and negative infinity around these areas.].

The ~get_circle_points_naive_8()~ function gets around this $y$-skip bug by invoking 8-way symmetry instead:

- i 2021-03-15-bresenham-circle-drawing-algorithm/naive.py 20-28

#+begin_export html
<canvas id="naive_8__15__20"></canvas>
#+end_export

However the downside is that it results in multiple points that will be drawn 2 times, wasting CPU cycles.[fn:: In the [[https://github.com/listx/listx_blog/blob/master/rust-js/src/lib.rs][Rust WASM implementation]] that is used for the graphics in this blog post, we actually use a bitmap such that we only draw a particular pixel just once. However, we still end up /setting/ the a pixel as "on" more than once.]
To be more precise, all points around the gappy area in Quadrant I are redundant because that part of the arc is already mirrored nicely by the contiguous points from $x = 0$ to $x = y$.

The ~get_circle_points_naive_8_faster()~ function avoids drawing the gappy areas by just breaking the loop when $x > y$, but is otherwise the same:

- i 2021-03-15-bresenham-circle-drawing-algorithm/naive.py 31-44

This is the best we can do with the simple mathematical translations to code.
Note that in all of these implementations we are still forced to calculate square roots in every iteration, which is certainly suboptimal.

* Bresenham's Algorithm

This as also known as the "Midpoint Circle Algorithm," where the name "midpoint" comes from the mathematical calculations that are done by considering the midpoint *between* pixels.
The gist of the algorithm is that instead of using Equation \(\ref{eq:circle-y}\) to calculate $y$ for every $x$, instead you try to /move/ along the arc of the circle, pixel-to-pixel, staying as close as possible to the true arc:

1) Start out from the top of the circle (color in pixel $(0, r)$). Note that because of symmetry, we could start out from $(0, -r)$, $(r, 0)$, or even $(-r, 0)$ as Bresenham did in his paper.[fn:: Bresenham, Jack. "A Linear Algorithm for Incremental Digital Display of Circular Arcs." Communications of the ACM, vol. 20, no. 2, 1977, pp. 100–106., doi:10.1145/359423.359432.]
2) Move right (east (E)) or down-right (southeast (SE)), whichever is closer to the circle.
3) Stop when $x = y$ (just like in ~get_circle_points_naive_8_faster()~).

The hard part is Step 2, where we just need to figure out which direction to move (E or SE) from the current pixel.
The brute force way here is to just calculate the distance away from the center of the circle for the E and SE pixels (using [[https://en.wikipedia.org/wiki/Euclidean_distance][Euclidean distance]], which is just a variation of Equation \(\ref{eq:circle}\) or the Pythagorean Theorem), and just choose the pixel that is closest to the arc of the circle.
This makes sense, but with the power of mathematics, we can do better.

** Inside, on, or outside the circle?

In order to figure out whether some point $(x, y)$ is inside, on, or outside of the circle depends on the definition of the circle from Equation \(\ref{eq:circle}\).
We can tweak it in terms of any $(x, y)$ pair:

\[
\begin{equation} \label{eq:error-margin}
F(x,y) = x^2 + y^2 - r^2 = \text{distance from true circle line}.
\end{equation}
\]

Note that if \(F(x,y) = 0\), then the point $(x, y)$ is /exactly/ on the circle.
If \(F(x,y) > 0\), then the point is outside of the circle, and if \(F(x,y) < 0\) then the point is inside of it.
In other words, given any point $(x, y)$, $F(x, y)$ is the distance from the true circle line.

** Choosing between E or SE

Let's remind ourselves that we'll always be moving E or SE.
One critical (pragmatic) property here is that we're dealing with a pixel grid with integer increments.
There is a very high chance that neither the E or SE pixels we're moving to is *exactly* on the circle.
This is because the only time that the point $(x,y)$ will exactly be on the line of the circle is if the $x$, $y$, and $r$ values (as integers) form a so-called [[https://en.wikipedia.org/wiki/Pythagorean_triple][Pythagorean Triple]].
For $r < 100$, there are only 50 such triples:

#+begin_src
( 3, 4, 5)  (18,24,30)  (24,45,51)  (16,63,65)  (51,68,85)
( 6, 8,10)  (16,30,34)  (20,48,52)  (32,60,68)  (40,75,85)
( 5,12,13)  (21,28,35)  (28,45,53)  (42,56,70)  (36,77,85)
( 9,12,15)  (12,35,37)  (33,44,55)  (48,55,73)  (13,84,85)
( 8,15,17)  (15,36,39)  (40,42,58)  (24,70,74)  (60,63,87)
(12,16,20)  (24,32,40)  (36,48,60)  (45,60,75)  (39,80,89)
(15,20,25)  ( 9,40,41)  (11,60,61)  (21,72,75)  (54,72,90)
( 7,24,25)  (27,36,45)  (39,52,65)  (30,72,78)  (35,84,91)
(10,24,26)  (30,40,50)  (33,56,65)  (48,64,80)  (57,76,95)
(20,21,29)  (14,48,50)  (25,60,65)  (18,80,82)  (65,72,97)
#+end_src

In other words, for all practical purposes, *there will always be some error* and we'll always be outside or inside the circle and never directly on it.
It's sort of like driving a car and trying to stay within your designated lane: if you think you're moving too much to the right, you turn your wheel left to stay "within" the lane (or some acceptable amount within the lane), and vice versa.

The idea is the same for moving along the circle: if we think we're moving too far /outside/ the circle, we try to move into it.
On the other hand, if we think we're moving /into/ the circle, we move out of it.
And so imagine yourself standing on point $(0, r)$, our starting point.
The line of the circle is our "lane" we want to stay "on" as much as possible.
Choosing to go E is the same as turning "left".
Choosing to go SE is the same as turning "right".
Using this metaphor, if we were not to turn at all (go "straight"), we would be heading to the virtual "in-between" pixel between E and SE, the *midpoint* between them.

And so here's the basic idea behind choosing E or SE:

1. If going "straight" would mean going into the circle (i.e., we're currently veering too much to the right!), we course-correct by turning left (E).
2. Conversely, if going "straight" would mean going outside the circle (i.e., we're currently veering too much to the left), we course-correct by turning right (SE).
3. Lastly, if going "straight" would mean staying exactly on the circle (we hit a Pythagorean Triple), we turn SE (it doesn't really matter which way we turn in this case, as both E and SE result in some amount of error).

Let's convert this idea into pseudocode:

#+begin_src -n 1
Let M be the midpoint (going "straight").

Then, F(M) tells us what direction we're headed relative to the true circle line.

If F(M) is < 0, we're moving "into" the circle (veering right), so turn left by moving E.

Otherwise move SE.
#+end_src

Note that we only have to calculate $F(...)$ for the midpoint $M$.
Isn't this cool?
It is much better than calculating $F(E)$ and $F(SE)$ and having to compare them!

#+begin_src python -n 1
# This F() function is the same as the mathematical F(...) function
# discussed above (Equation 11).
def F(x, y, r):
    return (x * x) + (y * y) - (r * r)

def get_circle_points_bresenham_WIP1(r):
    points = []
    x = 0
    y = r
    # Calculate F(M) for the very first time. That is, if we were to go
    # "straight" from (0, r), would we be inside or outside the circle?
    xE, yE = (1, r)
    xSE, ySE = (1, r - 1)
    xM, yM = (1, r - 0.5)
    F_M = F(xM, yM, r)
    points.extend(mirror_points_8(x, y))
    while x < y:
        # If going straight would go "into" the circle (too much to the
        # right), try to move out of it by turning left by moving E.
        if F_M < 0:
            x += 1
            F_M = F(x, y, r)
        # Otherwise move SE.
        else:
            x += 1
            y -= 1
            F_M = F(x, y, r)
        points.extend(mirror_points_8(x, y))
    return points
#+end_src

We can refactor the above slightly.
We can simplify the initial calculation of /F_M/ to avoid calling ~F()~, and also move out some of the redundant bits.
The math for the initial value of /F_M/ is

\[
\begin{align}
F(1, r - \tfrac{1}{2}) &= 1^2 + (r - \tfrac{1}{2})^2 - r^2
\\
&= 1 + (r^2 - r + \tfrac{1}{4}) - r^2
\\
&= 1 + r^2 - r^2 - r + \tfrac{1}{4}
\\
&= 1 - r + \tfrac{1}{4}
\\
&= \tfrac{5}{4} - r.
\end{align}
\]

With that said, we can get this:

#+begin_src python -n 1
def get_circle_points_bresenham_WIP2(r):
    points = []
    x = 0
    y = r
    F_M = 5/4 - r
    points.extend(mirror_points_8(x, y))
    while x < y:
        # If going straight would go "into" the circle (too much to the
        # right), try to move out of it by turning left by moving E.
        if F_M < 0:
            pass
        # Otherwise move SE.
        else:
            y -= 1
        x += 1
        F_M = F(x, y, r)
        points.extend(mirror_points_8(x, y))
    return points
#+end_src

The annoying bit is the call to ~F()~.
Surprisingly, the call to ~F()~ can be elimitated entirely, because we can /calculate it once/, and then merely adjust it thereafter.

** Calculate once, adjust thereafter

We can just calculate $F(x,y)$ /once/ when we start out at $(0, r)$, and then just /adjust it/ depending on whether we move E or SE.
The key is that this "adjustment" computation is cheaper than calculating the full $F(x,y)$ distance function all over again.

Let $M$ be the midpoint $(x + 1, y - \tfrac{1}{2})$ between the E $(x + 1, y)$ and SE $(x + 1, y - 1)$ pixels.
Then $F(M)$ is the result of going "straight" and tells us the direction we're veering off from the circle line:

\[
\begin{equation}
F(M) = F(x + 1, y - \tfrac{1}{2}) = (x + 1)^2 + (y - \tfrac{1}{2})^2 - r^2.
\end{equation}
\]

The values for $x$ and $y$ are unknown, however they change in only 2 possible ways --- by moving E or SE!

If we move E, then the new value of $F(M)$ will be:

\[
\begin{equation}
F(M_{E}) = F(x + 2, y - \tfrac{1}{2}) = (x + 2)^2 + (y - \tfrac{1}{2})^2 - r^2.
\end{equation}
\]

Now we can take the *difference* between these two full calculations.
That is, if we were to move E, how would $F(M)$ change?
Simple, we just look at the change in $x$ ($\Delta_{x}$) (we don't care about the change in $y$ or $r$, because they stay constant in this case).

\[
\begin{align}
\Delta_{E} = F(M_{E}) - F(M) &= \Delta_{x}
\\
&= (x + 2)^2 - (x + 1)^2 \label{eq:de1}
\\
&= (x^2 + 4x + 4) - (x^2 + 2x + 1)
\\
&= x^2 + 4x + 4 - x^2 - 2x - 1
\\
&= x^2 - x^2 + 4x - 2x + 4 - 1
\\
&= 2x + 3. \label{eq:de2}
\end{align}
\]

So $F(M)$ will change by $2x + 3$ if we move E.

How about for moving SE?
If we move SE, the new value of $F(M)$ will be:

\[
\begin{equation}
F(M_{SE}) = F(x + 2, y - \tfrac{3}{2}) = (x + 2)^2 + (y - \tfrac{3}{2})^2 - r^2.
\end{equation}
\]

We can do the same difference analysis to figure out how $F(M)$ will change if we move SE.
In this case we have to consider the change in $y$ ($\Delta_{y}$), because it obviously changes when moving SE:

\[
\begin{align}
\Delta_{SE} = F(M_{SE}) - F(M) &= \Delta_{x} + \Delta_{y}
\\
&= [(x + 2)^2 - (x + 1)^2] + [(y - \tfrac{3}{2})^2 - (y - \tfrac{1}{2})^2]
\\
&= (2x + 3) + [(y^2 - \tfrac{6y}{2} + \tfrac{9}{4}) - (y^2 - y + \tfrac{1}{4})]
\\
&= (2x + 3) + (y^2 - 3y + \tfrac{9}{4} - y^2 + y - \tfrac{1}{4})
\\
&= (2x + 3) + (y^2 - y^2 - 3y + y + \tfrac{9}{4} - \tfrac{1}{4})
\\
&= (2x + 3) + (- 2y + \tfrac{8}{4})
\\
&= (2x + 3) + (-2y + 2)
\\
&= 2x + 3 - 2y + 2
\\
&= 2x - 2y + 5
\\
&= 2(x - y) + 5.
\end{align}
\]

And so when moving SE, the new $F(M)$ must change by $2(x - y) + 5$.

Now we have all the pieces to derive the complete algorithm!

- i 2021-03-15-bresenham-circle-drawing-algorithm/bresenham.py 6-23

** Integer-only optimization

The initial value of $d$ ($F(M)$) is $\tfrac{5}{4} - r$.
Notice how this is the only place where we have to perform division in the whole algorithm.
We can avoid this initial division (and subsequent floating point arithmetic) by initializing it to $1 - r$ instead, which is a difference of $\tfrac{1}{4}$ vs the original.

Because we tweaked the initialization by $\tfrac{1}{4}$, we have to do the same for all comparisons of $d$ moving forward.
That is, the comparison $d < 0$ actually becomes $d < -\tfrac{1}{4}$.
/However, this fractional comparison is unnecessary/ because we only deal with integer increments and decrements in the rest of the code, so we can just keep the same $dm < 0$ as before.
In other words, our algorithm only cares about whole numbers, so worrying about this extra $\tfrac{1}{4}$ difference is meaningless.

- i 2021-03-15-bresenham-circle-drawing-algorithm/bresenham.py 26-45

** Second-order differences

There is a final optimization we can do.[fn:: It is not clear to me if this change runs faster on modern CPUs, because I recall reading that multiplication can sometimes be faster than adding. But it's still interesting.]
In the [[#calculate-once-adjust-thereafter]["Calculate once, adjust thereafter" section]] we avoided calculating $F(M)$ from scratch on every iteration.
We can do the same thing for the differences themselves!

That is, we can avoid calculating $\Delta_{E}$ and $\Delta_{SE}$ on every iteration, and instead just calculate them /once/ and make adjustments to them thereafter as well!

Let's first consider how $\Delta_{E} = 2x + 3$ changes.
First, we initialize $\Delta_{E}$ by plugging in $(0, r)$ into Equation \(\ref{eq:de2}\), our starting point.
Because there is no $y$ variable in here, we get an initial value of

\[
\begin{equation} \label{eq:de-2ord-initial}
2(0) + 3 = 3.
\end{equation}
\]

If we go E, $\Delta_{E}$ changes like this:
\[
\begin{align}
\Delta_{E_{new}} = \Delta_{E_(x+1,y)} - \Delta_{E_(x,y)} &= [2(x+1) + 3] - (2x + 3) \label{eq:de-2ord-e}
\\
&= 2x + 2 + 3 - 2x - 3
\\
&= 2x - 2x + 3 - 3 + 2
\\
&= 2.
\end{align}
\]

If we go SE, $\Delta_{E}$ changes in the exact same way, because even though our new point is at $(x+1, y-1)$, there is no $y$ in $\Delta_{E} = 2x + 3$, so it doesn't matter and $\Delta_{E_{new}} = 2$ again.

Now let's consider how $\Delta_{SE}$ changes.
For the initial value, we again plug in $(0, r)$ into $2(x-y) + 5$, to get

\[
\begin{equation} \label{eq:dse-2ord-initial}
2(0-r) + 5 = -2r + 5.
\end{equation}
\]

If we go E, $\Delta_{SE}$ changes like this:

\[
\begin{align}
\Delta_{SE_{new}} = \Delta_{SE_(x+1,y)} - \Delta_{SE_(x,y)} &= [2((x + 1)-y) + 5] - [2(x - y) + 5] \label{eq:dse-2ord-e}
\\
&= (2x + 2 - 2y + 5) - (2x - 2y + 5)
\\
&= 2x - 2y + 7 - 2x + 2y - 5
\\
&= 2x - 2x + 2y - 2y + 7 - 5
\\
&= 2.
\end{align}
\]

If we go SE, $\Delta_{SE}$ changes like this:

\[
\begin{align}
\Delta_{SE_{new}} = \Delta_{SE_(x+1,y-1)} - \Delta_{SE_(x,y)} &= [2((x + 1)-(y - 1)) + 5] - [2(x - y) + 5] \label{eq:dse-2ord-se}
\\
&= [2(x + 1 - y + 1) + 5] - (2x - 2y + 5)
\\
&= (2x + 2 - 2y + 2 + 5) - 2x + 2y - 5
\\
&= 2x- 2x + 2y - 2y + 5 - 5 + 2 + 2
\\
&= 2 + 2
\\
&= 4.
\end{align}
\]

The code should then look like this:

#+begin_src python -n 1
def get_circle_points_bresenham_2order(r):
    points = []
    x = 0
    y = r
    F_M = 1 - r
    d_e = 3 # Equation 36
    d_se = -(2 * r) + 5 # Equation 41
    points.extend(mirror_points_8(x, y))
    while x < y:
        if F_M < 0:
            F_M += d_e
            d_e += 2  # Equation 40
            d_se += 2 # Equation 46
        else:
            F_M += d_se
            d_e += 2  # Equation 40
            d_se += 4 # Equation 52
            y -= 1
        x += 1
        points.extend(mirror_points_8(x, y))
    return points
#+end_src

With a little refactoring, we can arrive at a slightly simpler version:

- i 2021-03-15-bresenham-circle-drawing-algorithm/bresenham.py 48-73

The "purist" in me felt that the decrementing of $y$ stood out like a sore thumb, and so I created a tweaked version that moves E and NE, starting out from $(0, -r)$ instead.
The mathematical techniques are the same, and due to symmetry the behavior of the algorithm does not change.

- i 2021-03-15-bresenham-circle-drawing-algorithm/bresenham.py 99-123

Here are a couple drawings using Bresenham's algorithm.
This one is for $r = 15$:

#+begin_export html
<canvas id="bresenham_integer_ene_2order__15__20"></canvas>
#+end_export

And for $r = 60$:

#+begin_export html
<canvas id="bresenham_integer_ene_2order__60__5"></canvas>
#+end_export

** Comparisons vs naive algorithm

Here are some side-by-side comparisons for $0 \leq r \leq 10$.

#+begin_export html
<table>
  <tr>
    <th>Radius</th>
    <th>Naive</th>
    <th>Bresenham</th>
  </tr>
  <tr>
    <td>0</td>
    <td><canvas id="naive_8__0__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__0__10"></canvas></td>
  </tr>
  <tr>
    <td>1</td>
    <td><canvas id="naive_8__1__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__1__10"></canvas></td>
  </tr>
  <tr>
    <td>2</td>
    <td><canvas id="naive_8__2__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__2__10"></canvas></td>
  </tr>
  <tr>
    <td>3</td>
    <td><canvas id="naive_8__3__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__3__10"></canvas></td>
  </tr>
  <tr>
    <td>4</td>
    <td><canvas id="naive_8__4__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__4__10"></canvas></td>
  </tr>
  <tr>
    <td>5</td>
    <td><canvas id="naive_8__5__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__5__10"></canvas></td>
  </tr>
  <tr>
    <td>6</td>
    <td><canvas id="naive_8__6__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__6__10"></canvas></td>
  </tr>
  <tr>
    <td>7</td>
    <td><canvas id="naive_8__7__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__7__10"></canvas></td>
  </tr>
  <tr>
    <td>8</td>
    <td><canvas id="naive_8__8__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__8__10"></canvas></td>
  </tr>
  <tr>
    <td>9</td>
    <td><canvas id="naive_8__9__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__9__10"></canvas></td>
  </tr>
  <tr>
    <td>10</td>
    <td><canvas id="naive_8__10__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__10__10"></canvas></td>
  </tr>
</table>
#+end_export

** Final tweaks

It has been kindly [[https://www.reddit.com/r/programming/comments/m5g8ck/bresenhams_circle_drawing_algorithm/gr23aie?utm_source=share&utm_medium=web2x&context=3][pointed out]] that the naive algorithm is aesthetically more pleasing if the calculations involving $r$ is done with $r + \tfrac{1}{2}$ instead of just $r$ itself, like this:

- i 2021-03-15-bresenham-circle-drawing-algorithm/naive.py 47-60

Indeed, the small tweak seems to do wonders to the output for low values of $r$.

At the same time, there is a tweak we can do as well for the Bresenham algorithm.
Instead of turning E ("left", or away from the circle) when $F(M) < 0$, we can do so when $F(M) \leq 0$.

- i 2021-03-15-bresenham-circle-drawing-algorithm/bresenham.py 126-148

This makes us turn "left" slightly more often, and intuitively, should give us a slightly larger circle.

Anyway, see for yourself how the tweaks play out for $0 \leq r \leq 10$:

#+begin_export html
<table>
  <tr>
    <th>Radius</th>
    <th>Naive</th>
    <th>Naive<br>(tweaked radius)</th>
    <th>Bresenham</th>
    <th>Bresenham<br>(tweaked conditional)</th>
  </tr>
  <tr>
    <td>0</td>
    <td><canvas id="naive_8__0__6"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__0__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__0__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__0__7"></canvas></td>
  </tr>
  <tr>
    <td>1</td>
    <td><canvas id="naive_8__1__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__1__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__1__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__1__7"></canvas></td>
  </tr>
  <tr>
    <td>2</td>
    <td><canvas id="naive_8__2__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__2__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__2__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__2__7"></canvas></td>
  </tr>
  <tr>
    <td>3</td>
    <td><canvas id="naive_8__3__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__3__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__3__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__3__7"></canvas></td>
  </tr>
  <tr>
    <td>4</td>
    <td><canvas id="naive_8__4__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__4__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__4__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__4__7"></canvas></td>
  </tr>
  <tr>
    <td>5</td>
    <td><canvas id="naive_8__5__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__5__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__5__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__5__7"></canvas></td>
  </tr>
  <tr>
    <td>6</td>
    <td><canvas id="naive_8__6__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__6__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__6__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__6__7"></canvas></td>
  </tr>
  <tr>
    <td>7</td>
    <td><canvas id="naive_8__7__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__7__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__7__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__7__7"></canvas></td>
  </tr>
  <tr>
    <td>8</td>
    <td><canvas id="naive_8__8__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__8__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__8__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__8__7"></canvas></td>
  </tr>
  <tr>
    <td>9</td>
    <td><canvas id="naive_8__9__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__9__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__9__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__9__7"></canvas></td>
  </tr>
  <tr>
    <td>10</td>
    <td><canvas id="naive_8__10__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__10__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__10__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__10__7"></canvas></td>
  </tr>
</table>
#+end_export

It appears to me that the most aesthetically pleasing algorithm is the tweaked version of the Bresenham algorithm.[fn:: This version looks slightly better than the tweaked naive one for $r = 8$.]
When given equally bad choices (the case where $F(M) = 0$), this version draws a pixel /away/ from the origin by choosing to go E, thereby drawing a slightly bigger circle.
You can see this play out in the above table for when $r = 6$ and especially $r = 1$.
It's a bit unfortunate that the authors of the book did not choose this version, as it seems to do a better job for small values of $r$.

We can carry over the same intuition over to the tweak to increase $r$ by $\tfrac{1}{2}$ for the naive algorithm --- increasing $r$ should result in a larger value of $y$, thereby resulting in drawing a larger circle (and in the process increasing the aesthetics).
Neat!

* Conclusion

To me, Bresenham's algorithm is interesting because it does not try to be "perfect".
Instead it merely does its best to reduce the amount of error, and in doing so, gets the job done remarkably well.

The technique of avoiding the full polynomial calculation behind $F(M)$ (referred by the book as finding the first and second-order differences) took some time to get used to, but is intuitive enough in the end.
You just need to consider differences in terms of variables.

I hope you learned something!

Happy hacking!
